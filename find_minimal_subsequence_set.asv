% Find minimal set of subsequences that will distinguish all sequences
% within a set.

%% Options

options.probe_size = [4]; % Set of probe sizes to use
options.max_trials = 100000; % Maximum number of probe sets to try
options.min_representation = 0; % Minimum number of target sequences for a probe to bind to
options.max_fraction_ambiguous = 0.2; % Maximum fraction of target sequences that cannot be distinguished for a probe set to be valid
options.max_fraction_missed = 0.05; % Maximum fraction of target sequences that can be missed for a probe set to be valid
options.starting_set = 30; % Starting size of probe sequence set
options.target_set_size = 16; % Desired size of probe sequence set
options.find_subsubseqs = 1; % Look for N-1 complementary regions within N-residue sub-sequences
options.gc_content_range = [0 1]; % inclusive range of allowed gc content for probe sequences
options.remove_self_complementary_probes = 1; % Remove self-complementary probes from candidate pool
options.stop_at_theoretical_minimum = 1; % Stop trying to reduce probe set size at theoretical minimum size for ternary code
options.eliminate_duplicate_targets = 1; % Eliminate any duplicate target sequences in the target set
options.max_self_complementarity = 2; % Maximum allowed self-complementarity

% Only consider certain parts of miRNA sequence for probe design.  n = use
% nucleotide, - = mask/do not use.
options.mask = '-nnnnnnn----nnnnnn------------------'; %g2-g8, g13-g18
% options.mask = '-nnnnnnn----nnnnnnnn---------------'; %g2-g8, g13-g20
% options.mask = 'nnnnnnnnnnn--------------------------'; %g1-g11
% options.mask = 'nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn';

% Required sequences to use in each probe set; will be ignored if it's not found in the target sequences
% options.required_sequences = {};
% required_sequences = {'TGGC'};
required_sequences = {'TGGC', 'TGTA'};
% required_sequences = {'TGGC','ATGG','TGTA','GTTA'}; 
% Unconstrained seq set for g2-g8 + g12-g18
% required_sequences = {'TATG', 'CTTG', 'GCCC','GTAG','AGCC', 'CCCA',	'AACT',	'ACAG',	'TGAG',	'CCAA', 'AGTG',	'TGCA',	'AGGG',	'GTCA'	,'TATC', 'CGGT'	, 'CACG', 	'GTTT',	'CTAG'	,'CTGG'};
% Seq set requiring 4 probe sequences for g2-g8 + g12-g18
% required_sequences = {'CTCG',	'ATGG',	'TTGA',	'CCTT',	'GTTA', 'ATAG',	'AGAT',	'TACT',	'TGCG',	'GGAC', 'GCTA',	'TGAG',	'TCAA',	'ACAT',	'TGGC', 'CAGT',	'TGTA',	'CACC',	'GGTG',	'TTAA'};

%% Target Sequences

% Giraldez et al. list of 966 miRNAs
% seqs_orig = load('C:\Users\aledb\Dropbox (Personal)\Alex\MATLAB Programs\Bioinformatics\Combinatorial SiMREPS\giraldez_miRNAs_966.mat');
% seqs_orig = seqs_orig.seqs;

% MirGeneDB 3.0 list of mature human miRNAs
miRNAs = fasta_read('C:\Users\aledb\Dropbox (Personal)\Alex\MATLAB Programs\Bioinformatics\Combinatorial SiMREPS\homo sapiens mature miRNAs mirGeneDB 3_0.fas');
seqs_orig = miRNAs(:,2);

% Walter lab miRNAs
% seqs_orig = walter_lab_miRNAs();

%% Main

seqs = seqs_orig;
for n = 1:length(seqs)
    seqs{n} = rna2dna(seqs{n}); % Convert RNA sequences to DNA equivalents
end

if options.eliminate_duplicate_targets == 1
    [seqs,ia] = unique(seqs(:,1),'stable'); % eliminate duplicate sequences
    if exist("miRNAs")==1
        seq_names = miRNAs(ia,1); % preserve names of miRNAs in curated list
    end
end

for n = 1:length(seqs)
    for m=1:length(seqs{n})
        if options.mask(m)=='-'
              seqs{n}(m)='-';
        end
    end
end

if options.stop_at_theoretical_minimum == 1
    theoretical_minimum = ceil(logN(size(seqs,1)+1,3)); % Theoretical minimum size of set, assuming ternary code
else
    theoretical_minimum = 0;
end

subseq_list = construct_nucleic_acid_subseqs(options.probe_size);

subseq_list = apply_gc_cutoffs(subseq_list,options.gc_content_range);

if options.remove_self_complementary_probes == 1 && options.max_self_complementarity < options.probe_size
    subseq_list = remove_self_complementary(subseq_list,options.max_self_complementarity+1);
end

nsubseqs = length(subseq_list);

is_subset = zeros(size(seqs,1),length(subseq_list)); % Initialize array of subsequence presence/absence in each sequence

for n = 1:nsubseqs
    if mod(n,100)==0
        % disp(num2str(n));
        fprintf(1,'Determined presence of %4u of %4u subsequences in sequence set.\n',n,nsubseqs);
    end
    for m = 1:length(seqs)
        % is_subset(m,n) = any(find(seqs{m},subseq_list{n}));
        is_subset(m,n) = contains(seqs{m,1},subseq_list{n});
    end
end

%% Find sub-subsequences (optional)

if options.find_subsubseqs == 1
    fprintf(1,'Finding which sub-subsequences are present in each target sequence...\n');
    % Make second pass to identify partial complementarity
    for n = 1:nsubseqs
        % determine subsubsequences
        m = 2; % number of subsubsequences
        subsubseqs = cell(m,1);
        for p = 1:m
            subsubseq = subseq_list{n}(p:p+2);
            % Check if subsubseq is a substring of each target; if so, label
            % it a 2
            for q = 1:size(seqs,1)
                if is_subset(q,n) == 0
                    if contains(seqs{q,1},subsubseq)==1
                        is_subset(q,n) = 2;
                    end
                end
            end
        end
    end
end

%% Evaluate candidate probe sets, finding lowest set size that satisfies requirements

representation = sum(double(is_subset>0),1);
hist(representation);
ind = find(representation>options.min_representation);

% Mark required sequences
options.required_sequence_ind = zeros(0,1);
for i = 1:length(options.required_sequences)
    for j = 1:length(ind)
        if strcmp(subseq_list{ind(j)},options.required_sequences{i})
            options.required_sequence_ind = cat(1,options.required_sequence_ind,j);
        end
    end
end

% Decrease probe number as much as feasible
ntrials = 0;
results.min_set = options.starting_set;
while ntrials<options.max_trials && results.min_set > max([theoretical_minimum, options.target_set_size])
    [ntrials, results] = test_probe_set(ntrials,subseq_list,is_subset,ind,options,results,'y');
end

% Optimize results with lowest feasible number of probes
ntrials = 0;
while ntrials<options.max_trials
    [ntrials, results] = test_probe_set(ntrials,subseq_list,is_subset,ind,options,results,'n');
end

results.ambiguous_idx = find(results.ambiguous_best);
results.degenerate_sequences = cell(length(results.ambiguous_best),1);
for m = 1:length(results.ambiguous_idx)
    [q, idx] = ismember(results.is_subset_best, results.is_subset_best(results.ambiguous_idx(m),:), 'rows');
    degenerate = find(idx);
    degenerate(degenerate==results.ambiguous_idx(m))=[]; % Remove self
    results.degenerate_sequences{results.ambiguous_idx(m)} = degenerate;
end

%% Display sets of degenerate sequences
list_ambiguous(seqs_orig,ia,seq_names,results.degenerate_sequences);

disp('Done');


%% Functions
function ind2 = enforce_required_sequences(ind,required_sequence_ind)
    ind2 = ind;
    % Enforce required sequences
    if isempty(required_sequence_ind) == 0
        for m = 1:length(required_sequence_ind)
            if sum(ind2==required_sequence_ind(m))==0
                replaced=0;
                while replaced==0
                    n=unidrnd(length(ind2));
                    if sum(required_sequence_ind==ind2(n))==0
                        ind2(n)=required_sequence_ind(m);
                        replaced = 1;
                    end
                end
            end
        end
    end
end

function y = construct_nucleic_acid_subseqs(K)
    x = 'ATGC';
    %// Sample data

%// Create all possible permutations (with repetition) of letters stored in x
C = cell(K, 1);             %// Preallocate a cell array
[C{:}] = ndgrid(x);         %// Create K grids of values
y = cellfun(@(x){x(:)}, C); %// Convert grids to column vectors
y = [y{:}];                 %// Obtain all permutations
y  = cellstr(y);
end

function seqs = walter_lab_miRNAs()
    seqs = cell(7,1);
    seqs{1} = rna2dna('UAACACUGUCUGGUAAAGAUGG');
    seqs{2} = rna2dna('UUUGUUCGUUCGGCUCGCGUGA');
    seqs{3} = rna2dna('UCACCGGGUGUAAAUCAGCUUG');
    seqs{4} = rna2dna('UGAGGUAGUAGGUUGUAUAGUU');
    seqs{5} = rna2dna('UAGCACCAUCUGAAAUCGGUUA');
    seqs{6} = rna2dna('UAGCAGCACGUAAAUAUUGGCG');
    seqs{7} = rna2dna('UAGCUUAUCAGACUGAUGUUGA');
end

function dna = rna2dna(rna)
    dna = rna;
    for n = 1:length(rna)
        if strcmp(rna(n),'U')
            dna(n)='T';
        end
    end
end

function rna = dna2rna(dna)
    rna = dna;
    for n = 1:length(dna)
        if strcmp(rna(n),'T')
            rna(n)='U';
        end
    end
end

function seqs = apply_gc_cutoffs(seqs,gc_content_range)
    N = length(seqs);
    for m = 1:N
        n = N-m+1;
        gc = (sum(seqs{n}=='C') + sum(seqs{n}=='G'))/length(seqs{n});
        if  gc < gc_content_range(1) || gc > gc_content_range(2)
            seqs(n) = [];
        end
    end
end

function seqs = remove_self_complementary(seqs,len)
    N = length(seqs);
    nsubseqs = length(seqs{1})-len+1;
    for m = 1:N
        n = N-m+1;
        seq = seqs{n};
        rc = reverse_complement(seq);
        removed = 0;
        for p = 1:nsubseqs
            for q = 1:nsubseqs
                if sum(seq(q:q+len-1)==rc(p:p+len-1))>=len && removed==0
                    % seq(q:q+len-1)
                    % rc(p:p+len-1)
                    % pause;
                    seqs(n)=[];
                    removed = 1;
                end
            end
        end
    end
end

function rc = reverse_complement(seq)
    rc = seq;
    for m = 1:length(seq)
        n = length(seq)-m+1;
        base = seq(n);
        if strcmp(base,'C')
            comp = 'G';
        elseif strcmp(base,'G')
            comp = 'C';
        elseif strcmp(base,'T')
            comp = 'A';
        elseif strcmp(base,'A')
            comp = 'T';
        end
        rc(m)=comp;
    end
end

function y = logN(x,N)
    y = log10(x)/log10(N);
end

function list_ambiguous(seqs_orig,ia,seq_names,degenerate_sequences)
    shown = [];
    seqs_orig = seqs_orig(ia);
    count = 0;
    for n = 1:length(seqs_orig)
        if isempty(degenerate_sequences{n})==0 && sum(shown==n)==0
            count = count+1;
            fprintf(1,"Showing degenerate sequence group %3u:\n",count)
            fprintf(1,strcat(seq_names{n},"  ",dna2rna(seqs_orig{n}),"\n"));
            shown = cat(1,shown,n);
            ind = degenerate_sequences{n};
            for p = 1:length(ind)
                fprintf(1,strcat(seq_names{ind(p)},"  ",dna2rna(seqs_orig{ind(p)}),"\n"));
                shown = cat(1,shown,ind(p));
            end
            fprintf(1,"\n");
            usr1 = input("q to quit, any other key for next group:","s");
            if strcmp(usr1,'q')
                break
            end
        end
    end
end

function [ntrials, results] = test_probe_set(ntrials,subseq_list,is_subset,ind,options,results,decrease_set)
    if mod(ntrials,1000)==0
        fprintf(1,'Trials completed: %3u \n',ntrials);
    end
    ambiguous = zeros(size(is_subset,1),1);
    if strcmp(decrease_set,'y')
        set_size = results.min_set-1;
    else
        set_size = results.min_set;
    end
    ind2 = randsample(length(ind),set_size,false);
    ind2 = enforce_required_sequences(ind2,options.required_sequence_ind); % Enforce required sequences, if any
    is_subset_2 = is_subset(:,ind(ind2));
    fail = 0;
    nmissed = sum(sum(is_subset_2,2)==0);
    [is_subset_3,~,idc] = unique(is_subset_2,'rows'); % Find unique rows
    for n = 1:length(idc)
        if sum(idc==idc(n))>1
            ambiguous(n)=1; % flag non-unique rows
        end
    end
    % nambiguous = size(is_subset_2,1)-size(is_subset_3,1);
    nambiguous = sum(ambiguous);
    if strcmp(decrease_set,'y')
        if nambiguous/size(is_subset_2,1) > options.max_fraction_ambiguous || nmissed/size(is_subset_2,1) > options.max_fraction_missed
            fail = 1;
        end
    else
        if nambiguous >= results.nambiguous_best || nmissed > results.nmissed_best
            fail = 1;
        end
    end
    if fail == 0
        results.min_set = set_size;
        results.subseqs_best = subseq_list(ind(ind2));
        results.nambiguous_best = nambiguous;
        results.ambiguous_best = ambiguous;
        results.nmissed_best = nmissed;
        results.is_subset_best = is_subset_2;
        fprintf(1,'Set of %3u subsequences found satisfying requirements. %3u ambiguous sequences (%.1f %%). %3u missed sequences (%.1f %%).\n',results.min_set,nambiguous,nambiguous/n*100,nmissed,nmissed/n*100);
    end
    results.fail = fail;
    ntrials = ntrials+1;
end